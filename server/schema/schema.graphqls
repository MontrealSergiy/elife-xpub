type Manuscript {
  id: ID!
  # Date type is not built in, need to import one
  created: Date!
  updated: Date!
  stage: Stage!
  coverLetter: String!
  "eLife 5 digit article ID which persists through to publication"
  articleIdentifier: String
  subjectAreas: [MajorSubjectArea!]!
  previouslyDiscussed: String
  # should this be null or an empty array when there is no previously submitted data?
  previouslySubmitted: [ArticleSearchParameters!]
  coSubmission: [ArticleSearchParameters!]
  relatedArticles: [RelatedArticle!]!
  suggestedEditors: [EditorSuggestion!]!
  excludedEditors: [EditorSuggestion!]!
  suggestedReviewers: [ReviewerSuggestion!]!
  excludedReviewers: [ReviewerSuggestion!]!
  # is this name too long?
  declarationOfNoConflictOfInterest: Boolean!
  persons: [ManuscriptPerson!]!
  qcIssues: [QCIssue!]!
}

# How to name stages?
# Active like 'QualityChecking' or passive like 'InQualityCheck' or past like 'Submitted'?
# Should all stages be prefixed with 'Initial' or 'Full' as in 'InitialQualityCheck' and 'FullQualityCheck'?
enum Stage {
  Created
  Submitted
  QualityCheckPassed
  DeputyEditorAssigned
  SeniorEditorAssigned
  #...
}

# How often do these change? Should they be queried from the elife API at runtime or embedded in the app?
enum MajorSubjectArea {
  Biochemistry
  CellBiology
  Neuroscience
  #...
}

type ArticleSearchParameters {
  title: String!
  author: String!
}

# Is is weird that this type has only one required field?
type ManuscriptPerson {
  user: User
  role: ManuscriptRole!
  # should alias actually be part of AuthorMetadata? It's only ever present for authors.
  # does the alias data have any use once the author is resolved to a user?
  alias: AuthorAlias
  metadata: ManuscriptPersonMetadata
}

type AuthorAlias {
  firstName: String!
  lastName: String!
  email: String!
  # Is this free text? The institution we get back from ORCID is disambiguated
  # but we lose that information if the author edits the field
  institution: String!
}

# Should this base interface have any fields?
interface ManuscriptPersonMetadata

type AuthorMetadata implements ManuscriptPersonMetatdata {
  rank: Int!
  coRelationship: ManuscriptPerson
  contributions: String
  conflictOfInterest: String
}

type ReviewerMetadata implements ManuscriptPersonMetatdata {
  # is rank always present?
  rank: Int
  coRelationship: ManuscriptPerson
  conflictOfInterest: String
  revealIdentity: Boolean
}

enum ManuscriptRole {
  DeputyEditor
  SeniorEditor
  ReviewingEditor
  Reviewer
  Author
  # The following two would have the same permissions as an Author but are
  # used for distinguishing the type of their relationship to the manuscript.
  # Is this mixing responsibilities? Would it be better to model this as data on AuthorMetadata?
  Submitter
  CorrespondingAuthor
}

type EditorSuggestion {
  user: User!
  role: ManuscriptRole!
  reason: String
}

type ReviewerSuggestion {
  name: String!
  email: String!
  role: ManuscriptRole!
  reason: String
}

type ChangeLog {
  id: ID!
  created: Date!
  # would all logged changes relate to a manuscript?
  manuscript: Manuscript
  user: User
  actions: [Action!]!
}

# to be defined
type Action

type File {
  # what is the URI? a path on the server? a file in an S3 bucket? a public URL?
  uri: String!
  type: FileType!
  # MIME type
  fileType: String!
}

# what is the file type used for? What do we need to distinguish?
enum FileType {
  ManuscriptSource
  Figure
  Dataset
  #...
}

type RelatedArticle {
  type: ArticleRelationship!
  articleIdentifier: String!
}

# what are the possible types of relationship? Same as JATS?
enum ArticleRelationship

type ArticleSearchParameters {
  title: String!
  correspondingAuthor: String!
  # Do we need in addition to 'manuscript.relatedArticles'?
  matchedRelation: RelatedArticle
}

# this extends the base type in pubsweet
extend type User {
  orcidId: String!
  roles: [GlobalRole!]!
}

enum GlobalRole {
  Staff
  EditorInChief
  # The following roles impart no extra permissions but allow the system to populate the list of editors
  DeputyEditor
  SeniorEditor
  ReviewingEditor
}

type QCIssue {
  id: ID!
  created: Date!
  manuscript: Manuscript!
  location: String!
  comments: [Comment!]!
  type: String!
  resolved: Boolean
}

type Comment {
  created: Date!
  user: User!
  text: String!
}
